# reactappcrashcourse


react hooks 
lets hook it up here 

useId Hook
Accessibility Attributes: Ensures stable and unique IDs for linking elements like buttons and descriptions.
Related Elements: Establishes clear relationships between labels and inputs for accessibility.
Shared Prefix: Provides a consistent naming convention for IDs, useful for debugging and avoiding collisions.
Client-Server Consistency: Prevents hydration mismatches by ensuring identical prefixes across environments.

examples 



### 1. **Generating Unique IDs for Accessibility Attributes**
Unique IDs are essential for accessibility attributes like `aria-describedby` or `aria-labelledby`. The `useId` hook ensures IDs are stable and unique.

```jsx
import React, { useId } from 'react';

function AccessibleButton() {
  const descriptionId = useId(); // Generate a unique ID for the description

  return (
    <div>
      <button aria-describedby={descriptionId}>Click Me</button>
      <p id={descriptionId}>
        This button performs an action when clicked.
      </p>
    </div>
  );
}

export default AccessibleButton;
```

**Explanation**:  
- The `descriptionId` is generated using `useId` and applied to the `id` of the descriptive `<p>` element.  
- The `aria-describedby` attribute on the `<button>` links it to the description, making it accessible for screen readers.

---

### 2. **Generating IDs for Several Related Elements**
When working with related elements, such as labels and inputs, you can use `useId` to generate consistent IDs.

```jsx
import React, { useId } from 'react';

function FormComponent() {
  const labelId = useId(); // Generate ID for the label
  const inputId = useId(); // Generate ID for the input

  return (
    <form>
      <label id={labelId} htmlFor={inputId}>
        Name:
      </label>
      <input id={inputId} type="text" aria-labelledby={labelId} />
    </form>
  );
}

export default FormComponent;
```

**Explanation**:  
- `labelId` is assigned to the `<label>`'s `id` and referenced in the `aria-labelledby` attribute of the `<input>`.  
- `inputId` ensures the `<input>` has a unique `id`, which is also referenced in the `htmlFor` attribute of the `<label>`.  
- This establishes a clear relationship between the label and the input for accessibility.

---

### 3. **Specifying a Shared Prefix for All Generated IDs**
React allows you to specify a shared prefix for all IDs generated by `useId` during server-side rendering. This is helpful for debugging and preventing collisions.

#### Server-Side Rendering Example:
```jsx
import ReactDOMServer from 'react-dom/server';
import React from 'react';
import FormComponent from './FormComponent';

const html = ReactDOMServer.renderToString(<FormComponent />, {
  identifierPrefix: 'myApp-' // Shared prefix for IDs
});

console.log(html);
```

**Explanation**:  
- The `identifierPrefix` option ensures all IDs generated by `useId` during server-side rendering have a consistent prefix, such as `myApp-`.  
- For example, IDs like `myApp-id-1`, `myApp-id-2` will be generated.

---

### 4. **Using the Same ID Prefix on the Client and the Server**
To prevent hydration mismatches, React ensures that the same prefix is used on the client and server. Here's how it works:

#### Client-Side Hydration Example:
```jsx
import React from 'react';
import { hydrate } from 'react-dom';
import FormComponent from './FormComponent';

hydrate(<FormComponent />, document.getElementById('root'), {
  identifierPrefix: 'myApp-' // Same prefix as server-side rendering
});
```

**Explanation**:  
- By using the same `identifierPrefix` on both the server and client, React ensures the IDs generated during hydration match the server-rendered IDs.  
- This prevents mismatches and ensures stable IDs across environments.


These practices make `useId` a powerful tool for managing IDs in React applications.

--------------

useState Hook

Here’s a detailed explanation of how to use the `useState` hook in React to handle various scenarios, along with examples and descriptions for each case:

---

### 1. **Adding State to a Component**
The `useState` hook allows you to add state to a functional component.



```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // Initialize state with 0

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

**Description**:  
- The `useState(0)` initializes the state variable `count` with `0`.  
- `setCount` is used to update the state when the button is clicked.

---

### 2. **Updating State Based on the Previous State**
When updating state based on the current value, use the functional form of `setState`.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>
        Increment
      </button>
    </div>
  );
}

export default Counter;
```

**Description**:  
- Instead of directly using `count + 1`, the functional form `(prevCount) => prevCount + 1` ensures the state update is based on the previous state, avoiding potential issues with stale state in asynchronous updates.

---

### 3. **Updating Objects and Arrays in State**
When working with objects or arrays in state, always create a new copy before updating.

#### Updating Objects:
```jsx
import React, { useState } from 'react';

function UserProfile() {
  const [user, setUser] = useState({ name: 'John', age: 30 });

  const updateAge = () => {
    setUser((prevUser) => ({ ...prevUser, age: prevUser.age + 1 }));
  };

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <button onClick={updateAge}>Increase Age</button>
    </div>
  );
}

export default UserProfile;
```

#### Updating Arrays:
```jsx
import React, { useState } from 'react';

function TodoList() {
  const [todos, setTodos] = useState(['Learn React', 'Build a Project']);

  const addTodo = () => {
    setTodos((prevTodos) => [...prevTodos, 'Read Documentation']);
  };

  return (
    <div>
      <ul>
        {todos.map((todo, index) => (
          <li key={index}>{todo}</li>
        ))}
      </ul>
      <button onClick={addTodo}>Add Todo</button>
    </div>
  );
}

export default TodoList;
```

**Description**:  
- For objects, use the spread operator (`...`) to create a new object before updating.  
- For arrays, use `...` to copy the existing array and add new items.

---

### 4. **Avoiding Recreating the Initial State**
When the initial state is expensive to calculate, use a function to initialize it lazily.

```jsx
import React, { useState } from 'react';

function ExpensiveCalculation() {
  const calculateInitialValue = () => {
    console.log('Expensive calculation...');
    return 42;
  };

  const [value, setValue] = useState(() => calculateInitialValue());

  return (
    <div>
      <p>Value: {value}</p>
      <button onClick={() => setValue(value + 1)}>Increment</button>
    </div>
  );
}

export default ExpensiveCalculation;
```

**Description**:  
- By passing a function (`() => calculateInitialValue()`), the calculation runs only once during the initial render, saving performance.

---

### 5. **Resetting State with a Key**
You can reset state by changing the component's `key` prop.

```jsx
import React, { useState } from 'react';

function ResettableCounter({ key }) {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

function App() {
  const [resetKey, setResetKey] = useState(0);

  return (
    <div>
      <ResettableCounter key={resetKey} />
      <button onClick={() => setResetKey((prevKey) => prevKey + 1)}>
        Reset Counter
      </button>
    </div>
  );
}

export default App;
```

**Description**:  
- Changing the `key` of a component forces React to unmount and remount it, resetting its state.

---

### 6. **Storing Information from Previous Renders**
To store information from previous renders, combine `useState` with `useRef`.

```jsx
import React, { useState, useEffect, useRef } from 'react';

function PreviousValueTracker() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();

  useEffect(() => {
    prevCountRef.current = count; // Store the current count as the previous count
  });

  const prevCount = prevCountRef.current;

  return (
    <div>
      <p>Current Count: {count}</p>
      <p>Previous Count: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default PreviousValueTracker;
```

special case here 

The useState Hook can be used to keep track of strings, numbers, booleans, arrays, objects, and any combination of these!

We could create multiple state Hooks to track individual values.
```jsx
import { useState } from "react";

function App() {
  const [car, setCar] = useState({
    brand: "Ford",
    model: "Mustang",
    year: "1964",
    color: "red"
  });

  // Function to update the car's color
  const updateColor = () => {
    setCar((prevCar) => ({
      ...prevCar, // Spread the previous car object
      color: "blue" // Update only the color
    }));
  };

  // Function to update the car's year
  const updateYear = () => {
    setCar((prevCar) => ({
      ...prevCar,
      year: "2023" // Update only the year
    }));
  };

  return (
    <>
      <h1>My {car.brand}</h1>
      <p>
        It is a {car.color} {car.model} from {car.year}.
      </p>
      <button onClick={updateColor}>Change Color</button>
      <button onClick={updateYear}>Update Year</button>
    </>
  );
}

export default App;
```

**Description**:  
- `useRef` is used to store the previous value of `count` across renders without triggering re-renders.  
- The `useEffect` hook updates the ref after each render.

---

### Summary:
| **Scenario**                               | **Key Concept**                                                                 |
|--------------------------------------------|---------------------------------------------------------------------------------|
| Adding state to a component                | Use `useState` to define a state variable and its updater function.             |
| Updating state based on the previous state | Use the functional form of `setState` to avoid stale state issues.              |
| Updating objects and arrays in state       | Always create a new copy using the spread operator (`...`) before updating.     |
| Avoiding recreating the initial state      | Use a lazy initializer (`() => value`) for expensive initial state calculations.|
| Resetting state with a key                 | Change the `key` prop to reset the state of a component.                        |
| Storing information from previous renders  | Use `useRef` to persist values across renders without causing re-renders.       |

useEffect Hook

1. Reference: Basic useEffect
The useEffect hook runs on every render unless controlled by dependencies.
jsx


```jsx
import { useEffect } from "react";

function BasicEffect() {
  useEffect(() => {
    console.log("Effect ran on every render");
  });

  return <h1>Check the console!</h1>;
}

export default BasicEffect;
2. No Dependency Array
When no dependency array is provided, the effect runs on every render.
jsx


```jsx
import { useState, useEffect } from "react";

function NoDependencyEffect() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Effect ran because it has no dependencies.");
  });

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <p>Count: {count}</p>
    </div>
  );
}

export default NoDependencyEffect;
3. Empty Dependency Array
An empty dependency array ensures the effect runs only once, on the initial render.
jsx


```jsx
import { useState, useEffect } from "react";

function EmptyDependencyEffect() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Effect ran on the first render only.");
  }, []);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <p>Count: {count}</p>
    </div>
  );
}

export default EmptyDependencyEffect;
4. Dependency Array with State or Props
The effect runs whenever the specified dependency changes.
jsx


```jsx
import { useState, useEffect } from "react";

function DependencyEffect() {
  const [count, setCount] = useState(0);
  const [calculation, setCalculation] = useState(0);

  useEffect(() => {
    setCalculation(() => count * 2); // Runs whenever `count` changes
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <p>Count: {count}</p>
      <p>Calculation: {calculation}</p>
    </div>
  );
}

export default DependencyEffect;
5. Effect Cleanup
Cleanup logic is added to prevent memory leaks, such as clearing timers or unsubscribing from listeners.
jsx

```jsx
import { useState, useEffect } from "react";

function CleanupEffect() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setTimeout(() => {
      setCount((c) => c + 1);
    }, 1000);

    return () => clearTimeout(timer); // Cleanup logic
  }, []);

  return <h1>Count: {count}</h1>;
}

export default CleanupEffect;
6. Fetching Data with Effects
Use useEffect to fetch data from an API.
jsx


```jsx
import { useState, useEffect } from "react";

function FetchDataEffect() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/posts/1")
      .then((response) => response.json())
      .then((json) => setData(json));
  }, []);

  return (
    <div>
      <h1>Data Fetch Example</h1>
      {data ? <p>{data.title}</p> : <p>Loading...</p>}
    </div>
  );
}

export default FetchDataEffect;
7. Updating State Based on Previous State
Update state based on previous state using effects.
jsx


```jsx
import { useState, useEffect } from "react";

function UpdateStateEffect() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Count updated:", count);
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <p>Count: {count}</p>
    </div>
  );
}

export default UpdateStateEffect;
8. Removing Unnecessary Object Dependencies
Avoid unnecessary re-renders by using specific dependencies.
jsx


```jsx
import { useState, useEffect } from "react";

function ObjectDependencyEffect() {
  const [user, setUser] = useState({ name: "John", age: 25 });

  useEffect(() => {
    console.log("User's age changed:", user.age);
  }, [user.age]); // Only depend on `user.age`

  return (
    <div>
      <button onClick={() => setUser({ ...user, age: user.age + 1 })}>
        Increment Age
      </button>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
    </div>
  );
}

export default ObjectDependencyEffect;
9. Custom Hook for Effects
Wrap effects inside custom hooks for reusability.
jsx


```jsx
import { useState, useEffect } from "react";

function useFetchData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((response) => response.json())
      .then((json) => setData(json));
  }, [url]);

  return data;
}

```jsx
function CustomHookEffect() {
  const data = useFetchData("https://jsonplaceholder.typicode.com/posts/1");

  return (
    <div>
      <h1>Custom Hook Example</h1>
      {data ? <p>{data.title}</p> : <p>Loading...</p>}
    </div>
  );
}
```
export default CustomHookEffect;
10. Troubleshooting: Infinite Cycle
Avoid infinite re-renders by carefully managing dependencies.

```jsx
import { useState, useEffect } from "react";

function InfiniteCycleEffect() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount((c) => c + 1); // Infinite loop if no dependency array
  }, []); // Fix with dependency array

  return <h1>Count: {count}</h1>;
}

export default InfiniteCycleEffect;
```
Fetching Data with Axios and useEffect

```jsx
import React, { useState, useEffect } from "react";
import axios from "axios";

function AxiosDataFetch() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Fetch data using axios
    axios
      .get("https://jsonplaceholder.typicode.com/posts/1")
      .then((response) => {
        setData(response.data); // Set the fetched data
        setLoading(false); // Set loading to false
      })
      .catch((err) => {
        setError(err.message); // Handle errors
        setLoading(false);
      });
  }, []); // Empty dependency array ensures it runs only once

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <h1>Data Fetched with Axios</h1>
      <h2>Title: {data.title}</h2>
      <p>Body: {data.body}</p>
    </div>
  );
}

export default AxiosDataFetch;
```

useLayoutEffect Hook

1. Basic Example of useLayoutEffect
This example demonstrates how useLayoutEffect runs before the browser repaints the screen.
jsx

```jsx
import React, { useLayoutEffect, useState } from "react";

function BasicUseLayoutEffect() {
  const [text, setText] = useState("Initial text");

  useLayoutEffect(() => {
    console.log("useLayoutEffect runs before the browser repaints");
    setText("Updated text");
  }, []);

  return <h1>{text}</h1>;
}

export default BasicUseLayoutEffect;
Explanation:
useLayoutEffect updates the state (text) before the browser repaints the screen.
The user will only see the updated text ("Updated text") because the browser does not paint the initial text.
2. DOM Measurement and Manipulation
This example demonstrates measuring the DOM before the browser repaints the screen.
jsx

```jsx
import React, { useLayoutEffect, useRef, useState } from "react";

function MeasureDOM() {
  const boxRef = useRef(null);
  const [boxWidth, setBoxWidth] = useState(0);

  useLayoutEffect(() => {
    const width = boxRef.current.getBoundingClientRect().width;
    setBoxWidth(width);
    console.log("Measured box width:", width);
  }, []);

  return (
    <div>
      <div ref={boxRef} style={{ width: "300px", height: "100px", backgroundColor: "lightblue" }}>
        Box
      </div>
      <p>Box width: {boxWidth}px</p>
    </div>
  );
}

export default MeasureDOM;
Explanation:
useLayoutEffect measures the width of the box using getBoundingClientRect before the browser repaints.
This ensures accurate layout measurements for rendering logic.
3. Tooltip Positioning
This example demonstrates positioning a tooltip based on its height.
jsx

```jsx
import React, { useLayoutEffect, useRef, useState } from "react";

function Tooltip({ targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      tooltipY = targetRect.bottom; // Place below if it doesn't fit above
    }
  }

  return (
    <div
      ref={ref}
      style={{
        position: "absolute",
        left: tooltipX,
        top: tooltipY,
        backgroundColor: "black",
        color: "white",
        padding: "5px",
      }}
    >
      Tooltip Content
    </div>
  );
}

export default Tooltip;
Explanation:
The tooltip height is measured using useLayoutEffect, and the tooltip is positioned accordingly before the browser repaints.
This avoids flickering or incorrect positioning during rendering.
4. Troubleshooting: Server-Side Rendering
useLayoutEffect does not run on the server. Here’s how to handle it.
Example: Replace useLayoutEffect with useEffect for server rendering.
jsx

```jsx
import React, { useEffect, useRef, useState } from "react";

function ServerSafeTooltip({ targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      tooltipY = targetRect.bottom;
    }
  }

  return (
    <div
      ref={ref}
      style={{
        position: "absolute",
        left: tooltipX,
        top: tooltipY,
        backgroundColor: "black",
        color: "white",
        padding: "5px",
      }}
    >
      Tooltip Content
    </div>
  );
}

export default ServerSafeTooltip;
Explanation:
useEffect is used instead of useLayoutEffect because it works on both the client and server.
This approach avoids errors and ensures compatibility during server-side rendering.
5. Cleanup in useLayoutEffect
This example demonstrates how to clean up effects.
jsx

```jsx
import React, { useLayoutEffect, useRef } from "react";

function CleanupExample() {
  const boxRef = useRef(null);

  useLayoutEffect(() => {
    const handleResize = () => {
      console.log("Resized box:", boxRef.current.getBoundingClientRect().width);
    };

    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      console.log("Cleanup: removed resize listener");
    };
  }, []);

  return <div ref={boxRef} style={{ width: "300px", height: "100px", backgroundColor: "lightcoral" }}>Resize Me!</div>;
}

export default CleanupExample;
Explanation:
useLayoutEffect adds a resize event listener and cleans it up when the component unmounts.
This prevents memory leaks and ensures proper cleanup.
6. Comparing useLayoutEffect vs useEffect
Here’s an example to demonstrate the difference between useLayoutEffect and useEffect.
jsx

```jsx
import React, { useLayoutEffect, useEffect, useRef } from "react";

function CompareEffects() {
  const ref = useRef(null);

  useLayoutEffect(() => {
    console.log("useLayoutEffect: Runs before browser repaint");
    ref.current.style.color = "red";
  }, []);

  useEffect(() => {
    console.log("useEffect: Runs after browser repaint");
    ref.current.style.color = "blue";
  }, []);

  return <h1 ref={ref}>Effect Comparison</h1>;
}

export default CompareEffects;
Explanation:

useLayoutEffect updates the text color to red before the browser repaints.

useEffect updates the text color to blue after the browser repaints.

You’ll see the text color change to blue after the initial render.

Key Points to Remember

Performance:
useLayoutEffect blocks the browser from repainting, which can hurt performance if used excessively.

Prefer useEffect unless you need layout measurements or DOM manipulation before the repaint.

Server-Side Rendering:

useLayoutEffect does not run on the server. Replace it with useEffect or use client-only rendering.

Cleanup:

Always include cleanup logic in useLayoutEffect to avoid memory leaks.

Dependencies:

Specify all reactive dependencies in the dependency array to avoid unnecessary re-renders.

useCallback hook

Here is a comprehensive explanation and code examples for using the `useCallback` hook in React, addressing the following scenarios:

1. **Skipping re-rendering of components**  
2. **Updating state from a memoized callback**  
3. **Preventing an Effect from firing too often**  
4. **Optimizing a custom Hook**

---

### **1. Skipping Re-rendering of Components**

#### Code Example:

`App.js`:
```jsx
import { useState, useCallback } from "react";
import ReactDOM from "react-dom/client";
import Todos from "./Todos";

function App() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  const increment = () => {
    setCount((c) => c + 1);
  };

  // Memoized version of addTodo
  const addTodo = useCallback(() => {
    setTodos((t) => [...t, "New Todo"]);
  }, [todos]);

  return (
    <>
      <Todos todos={todos} addTodo={addTodo} />
      <hr />
      <div>
        Count: {count}
        <button onClick={increment}>+</button>
      </div>
    </>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

`Todos.js`:
```jsx
import { memo } from "react";

const Todos = ({ todos, addTodo }) => {
  console.log("Todos component re-rendered");
  return (
    <>
      <h2>My Todos</h2>
      {todos.map((todo, index) => (
        <p key={index}>{todo}</p>
      ))}
      <button onClick={addTodo}>Add Todo</button>
    </>
  );
};

export default memo(Todos);
```

#### Explanation:
- **Problem**: Without `useCallback`, the `addTodo` function is recreated on every render, causing the `Todos` component to re-render unnecessarily.
- **Solution**: Wrapping `addTodo` with `useCallback` ensures that the function is only recreated when its dependencies (`todos`) change. This prevents the `Todos` component from re-rendering unless necessary.

---

### **2. Updating State from a Memoized Callback**

#### Code Example:

```jsx
import React, { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // Memoized increment function
  const increment = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

export default Counter;
```

#### Explanation:
- `increment` is wrapped with `useCallback` to ensure it is not recreated on every render.
- This is particularly useful when passing `increment` as a prop to child components, avoiding unnecessary re-renders.

---

### **3. Preventing an Effect from Firing Too Often**

#### Code Example:

```jsx
import React, { useState, useCallback, useEffect } from "react";

function Search() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  // Memoized search function
  const fetchResults = useCallback(() => {
    console.log("Fetching results for:", query);
    setResults([`Result for "${query}"`]); // Mock API result
  }, [query]);

  useEffect(() => {
    fetchResults();
  }, [fetchResults]);

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>
    </div>
  );
}

export default Search;
```

#### Explanation:
- The `fetchResults` function is memoized using `useCallback` and only changes when `query` changes.
- This prevents the `useEffect` from firing unnecessarily, optimizing performance.

---

### **4. Optimizing a Custom Hook**

#### Code Example:

`useDebounce.js`:
```jsx
import { useState, useEffect, useCallback } from "react";

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  const debounce = useCallback(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  useEffect(() => {
    return debounce();
  }, [debounce]);

  return debouncedValue;
}

export default useDebounce;
```

`App.js`:
```jsx
import React, { useState } from "react";
import useDebounce from "./useDebounce";

function App() {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 500);

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Type something..."
      />
      <p>Debounced Query: {debouncedQuery}</p>
    </div>
  );
}

export default App;
```

#### Explanation:
- **Custom Hook**: `useDebounce` delays updates to the `debouncedValue` until the user stops typing for a specified delay (500ms in this case).
- **Optimization**: The `debounce` logic is memoized using `useCallback`, ensuring it is not recreated unnecessarily.

---

### Summary of Scenarios and Benefits

| **Scenario**                          | **Benefit of `useCallback`**                                                                 |
|---------------------------------------|---------------------------------------------------------------------------------------------|
| Skipping re-rendering of components   | Prevents unnecessary re-renders by memoizing callback functions passed as props.           |
| Updating state from a memoized callback | Ensures state updates are optimized and callbacks are not recreated unnecessarily.          |
| Preventing an Effect from firing too often | Avoids redundant effect executions by reusing memoized functions.                           |
| Optimizing a custom Hook              | Improves custom hook performance by memoizing internal logic and dependencies.             |

---

### Key Points to Remember:
1. **When to Use**:
   - Use `useCallback` when passing functions as props to child components wrapped in `React.memo`.
   - Use it to optimize custom hooks or prevent unnecessary re-renders.

2. **Dependencies**:
   - Always specify dependencies correctly in the dependency array to avoid stale closures.

3. **Difference from `useMemo`**:
   - `useCallback` returns a memoized **function**, while `useMemo` returns a memoized **value**.

useMemo Hook 

Here is a detailed explanation of the `useMemo` hook in React, covering its definitions, functionality, and examples for the following use cases:

---

## **What is `useMemo`?**
The `useMemo` hook allows you to **cache the result of a calculation** between re-renders. This improves performance by skipping unnecessary recalculations. It is particularly helpful for:
- **Skipping expensive recalculations**: Avoid recalculating values unless dependencies change.
- **Skipping re-rendering of components**: Prevent unnecessary re-renders of child components.
- **Preventing an Effect from firing too often**: Ensure that dependencies don’t trigger effects unnecessarily.
- **Memoizing a dependency of another Hook**: Cache intermediate values required by other hooks.
- **Memoizing a function**: Cache a function to ensure it has the same reference between renders.

---

## **Syntax**
```jsx
const memoizedValue = useMemo(() => calculateValue(), [dependencies]);
```

- **`calculateValue`**: A function that performs the calculation you want to memoize.
- **`dependencies`**: An array of values that, when changed, will re-trigger the calculation.

---

## **Examples**

### **1. Skipping Expensive Recalculations**

#### Code Example:
```jsx
import React, { useState, useMemo } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  // Memoized expensive calculation
  const calculation = useMemo(() => expensiveCalculation(count), [count]);

  const increment = () => {
    setCount((c) => c + 1);
  };

  const addTodo = () => {
    setTodos((t) => [...t, "New Todo"]);
  };

  return (
    <div>
      <div>
        <h2>My Todos</h2>
        {todos.map((todo, index) => (
          <p key={index}>{todo}</p>
        ))}
        <button onClick={addTodo}>Add Todo</button>
      </div>
      <hr />
      <div>
        <h2>Expensive Calculation</h2>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
        <p>Result: {calculation}</p>
      </div>
    </div>
  );
}

const expensiveCalculation = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
  return num;
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

#### Explanation:
- The `expensiveCalculation` function is memoized using `useMemo`, so it only runs when the `count` changes.
- Without `useMemo`, this function would run on every render, causing performance issues.

---

### **2. Skipping Re-rendering of Components**

#### Code Example:
`App.js`:
```jsx
import React, { useState, useMemo } from "react";
import ReactDOM from "react-dom/client";
import List from "./List";

function App() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  const visibleTodos = useMemo(() => filterTodos(todos), [todos]);

  const increment = () => {
    setCount((c) => c + 1);
  };

  const addTodo = () => {
    setTodos((t) => [...t, "New Todo"]);
  };

  return (
    <div>
      <List items={visibleTodos} />
      <hr />
      <div>
        <h2>Counter</h2>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
        <button onClick={addTodo}>Add Todo</button>
      </div>
    </div>
  );
}

const filterTodos = (todos) => {
  console.log("Filtering Todos...");
  return todos.filter((todo) => todo.includes("Todo"));
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

`List.js`:
```jsx
import React from "react";

const List = React.memo(({ items }) => {
  console.log("Rendering List...");
  return (
    <div>
      <h2>Todos</h2>
      {items.map((item, index) => (
        <p key={index}>{item}</p>
      ))}
    </div>
  );
});

export default List;
```

#### Explanation:
- The `filterTodos` function is memoized using `useMemo`, so it only runs when `todos` change.
- The `List` component is wrapped in `React.memo`, so it only re-renders when its `items` prop changes.

---

### **3. Preventing an Effect from Firing Too Often**

#### Code Example:
```jsx
import React, { useState, useMemo, useEffect } from "react";

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  const options = useMemo(() => {
    return {
      serverUrl: "https://localhost:1234",
      roomId,
    };
  }, [roomId]);

  useEffect(() => {
    console.log("Connecting to chat room:", options.roomId);
    const connection = { connect: () => {}, disconnect: () => {} }; // Mock connection
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <div>
      <h2>Chat Room {roomId}</h2>
      {messages.map((message, index) => (
        <p key={index}>{message}</p>
      ))}
    </div>
  );
}

export default ChatRoom;
```

#### Explanation:
- The `options` object is memoized using `useMemo`, so it only changes when `roomId` changes.
- This prevents the `useEffect` from firing unnecessarily.

---

### **4. Memoizing a Dependency of Another Hook**

#### Code Example:
```jsx
import React, { useMemo } from "react";

function Dropdown({ allItems, text }) {
  const visibleItems = useMemo(() => {
    const searchOptions = { matchMode: "whole-word", text };
    return searchItems(allItems, searchOptions);
  }, [allItems, text]);

  return (
    <ul>
      {visibleItems.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

const searchItems = (items, options) => {
  console.log("Searching Items...");
  return items.filter((item) =>
    options.matchMode === "whole-word"
      ? item === options.text
      : item.includes(options.text)
  );
};

export default Dropdown;
```

#### Explanation:
- The `visibleItems` array is memoized using `useMemo`, so the `searchItems` function only runs when `allItems` or `text` changes.

---

### **5. Memoizing a Function**

#### Code Example:
```jsx
import React, { useMemo } from "react";

function ProductPage({ productId, referrer }) {
  const handleSubmit = useMemo(() => {
    return (orderDetails) => {
      console.log("Submitting order for product:", productId);
      console.log("Referrer:", referrer);
    };
  }, [productId, referrer]);

  return <Form onSubmit={handleSubmit} />;
}

function Form({ onSubmit }) {
  return (
    <button onClick={() => onSubmit({ quantity: 1 })}>Submit Order</button>
  );
}

export default ProductPage;
```

#### Explanation:
- The `handleSubmit` function is memoized using `useMemo`, so its reference remains the same unless `productId` or `referrer` changes.

---

## **Key Takeaways**
1. **When to Use `useMemo`**:
   - Use it to optimize expensive calculations.
   - Use it when passing derived values to memoized child components.

2. **Avoid Overuse**:
   - Only use `useMemo` for performance optimization. If the app works without it, it’s not necessary.

3. **Difference Between `useMemo` and `useCallback`**:
   - `useMemo` memoizes a **value**.
   - `useCallback` memoizes a **function**.

useReducer Hook

Here’s a complete example of using the `useReducer` hook in a React application. This example demonstrates how to manage a list of todos with the ability to toggle their completion status, add new todos, and remove todos.

---

### **Complete Code Example: Todo App with `useReducer`**

#### **App.js**
```jsx
import React, { useReducer, useState } from "react";
import ReactDOM from "react-dom/client";

// Initial state for the todos
const initialTodos = [
  {
    id: 1,
    title: "Learn React",
    complete: false,
  },
  {
    id: 2,
    title: "Practice useReducer",
    complete: false,
  },
];

// Reducer function to handle state transitions
const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TODO":
      return [
        ...state,
        { id: Date.now(), title: action.title, complete: false },
      ];
    case "TOGGLE_TODO":
      return state.map((todo) =>
        todo.id === action.id ? { ...todo, complete: !todo.complete } : todo
      );
    case "REMOVE_TODO":
      return state.filter((todo) => todo.id !== action.id);
    default:
      return state;
  }
};

function App() {
  const [todos, dispatch] = useReducer(reducer, initialTodos);
  const [newTodo, setNewTodo] = useState("");

  const handleAddTodo = () => {
    if (newTodo.trim() !== "") {
      dispatch({ type: "ADD_TODO", title: newTodo });
      setNewTodo(""); // Clear input field
    }
  };

  const handleToggleTodo = (id) => {
    dispatch({ type: "TOGGLE_TODO", id });
  };

  const handleRemoveTodo = (id) => {
    dispatch({ type: "REMOVE_TODO", id });
  };

  return (
    <div style={{ padding: "20px" }}>
      <h1>Todo App</h1>

      {/* Input and Add Button */}
      <div>
        <input
          type="text"
          value={newTodo}
          onChange={(e) => setNewTodo(e.target.value)}
          placeholder="Add a new todo..."
        />
        <button onClick={handleAddTodo}>Add</button>
      </div>

      {/* List of Todos */}
      <ul style={{ listStyleType: "none", padding: 0 }}>
        {todos.map((todo) => (
          <li key={todo.id} style={{ margin: "10px 0" }}>
            <label>
              <input
                type="checkbox"
                checked={todo.complete}
                onChange={() => handleToggleTodo(todo.id)}
              />
              <span
                style={{
                  textDecoration: todo.complete ? "line-through" : "none",
                  marginLeft: "10px",
                }}
              >
                {todo.title}
              </span>
            </label>
            <button
              onClick={() => handleRemoveTodo(todo.id)}
              style={{ marginLeft: "10px", color: "red" }}
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

---

### **Explanation of the Code**

#### **1. Initial State**
The `initialTodos` variable defines the starting state of the application. It is an array of todo objects, each with:
- `id`: A unique identifier for the todo.
- `title`: The text of the todo.
- `complete`: A boolean indicating whether the todo is completed.

#### **2. Reducer Function**
The `reducer` function handles state transitions based on the action type:
- **`ADD_TODO`**: Adds a new todo to the list, using `Date.now()` for a unique ID.
- **`TOGGLE_TODO`**: Toggles the `complete` status of a todo by mapping through the state and updating the matched todo.
- **`REMOVE_TODO`**: Removes a todo by filtering it out of the state.

#### **3. `useReducer` Hook**
The `useReducer` hook is used to manage the `todos` state:
```jsx
const [todos, dispatch] = useReducer(reducer, initialTodos);
```
- `todos`: The current state.
- `dispatch`: A function to send actions to the reducer.

#### **4. Adding a New Todo**
The `handleAddTodo` function dispatches an `ADD_TODO` action with the `title` of the new todo. It also clears the input field after adding.

#### **5. Toggling a Todo**
The `handleToggleTodo` function dispatches a `TOGGLE_TODO` action with the `id` of the todo to toggle.

#### **6. Removing a Todo**
The `handleRemoveTodo` function dispatches a `REMOVE_TODO` action with the `id` of the todo to remove.

#### **7. UI Rendering**
- The `input` field allows users to type a new todo.
- The `ul` element renders the list of todos. Each todo has:
  - A checkbox to toggle its completion status.
  - A delete button to remove it.

---

### **Features of the App**
1. **Add a Todo**: Type in the input field and click the "Add" button.
2. **Toggle Completion**: Check/uncheck the checkbox to toggle the `complete` status.
3. **Delete a Todo**: Click the "Delete" button to remove a todo.

---

### **How to Run**
1. Create a new React app using `create-react-app` or any other setup.
2. Replace the contents of `App.js` with the code above.
3. Run the app using `npm start` or `yarn start`.

---

### **Key Takeaways**
1. **Why `useReducer`?**
   - It’s useful for managing complex state logic, especially when the state depends on multiple actions.

2. **Advantages Over `useState`**:
   - Centralized state logic in the `reducer` function.
   - Easier to manage and extend when adding new actions.

3. **Avoiding Recreating Initial State**:
   - The `initialTodos` array is defined outside the component to avoid being recreated on every render.

useRef Hook

Here’s a detailed explanation and examples of the `useRef` hook in React, covering the following use cases:

1. **Referencing a Value with a Ref**  
2. **Manipulating the DOM with a Ref**  
3. **Avoiding Recreating the Ref Contents**

---

### **What is `useRef`?**
The `useRef` hook is used to:
- Store a **mutable reference** to a value or DOM element.
- Persist a value across renders **without causing re-renders**.
- Avoid reinitializing values on every render.

---

### **Syntax**
```jsx
const ref = useRef(initialValue);
```

- **`ref.current`**: Holds the mutable value (can be an object, DOM node, or any value).
- **`initialValue`**: The initial value assigned to the `ref`.

---

### **1. Referencing a Value with a Ref**

#### Code Example:
```jsx
import React, { useRef } from "react";
import ReactDOM from "react-dom/client";

function Counter() {
  const countRef = useRef(0); // Initialize the ref with 0

  const increment = () => {
    countRef.current += 1; // Update the ref value
    console.log("Current count (ref):", countRef.current);
  };

  return (
    <div>
      <h1>Counter with useRef</h1>
      <button onClick={increment}>Increment</button>
      <p>
        Check the console to see the current count. It won't cause a re-render.
      </p>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<Counter />);
```

#### Explanation:
- `countRef` is a mutable reference that holds the count value.
- Updating `countRef.current` does **not** trigger a re-render.
- The value persists across renders but is only accessible programmatically.

---

### **2. Manipulating the DOM with a Ref**

#### Code Example:
```jsx
import React, { useRef } from "react";
import ReactDOM from "react-dom/client";

function InputFocus() {
  const inputRef = useRef(null); // Create a ref to hold the input element

  const focusInput = () => {
    inputRef.current.focus(); // Access the DOM element and focus it
  };

  return (
    <div>
      <h1>Manipulating the DOM with useRef</h1>
      <input ref={inputRef} type="text" placeholder="Click the button to focus" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<InputFocus />);
```

#### Explanation:
- `inputRef` holds a reference to the `<input>` DOM element.
- `inputRef.current` is used to call the `.focus()` method on the input field.
- This is useful for direct DOM manipulation (e.g., focusing, scrolling, or selecting elements).

---

### **3. Avoiding Recreating the Ref Contents**

#### Code Example:
```jsx
import React, { useRef, useState } from "react";
import ReactDOM from "react-dom/client";

function Timer() {
  const timerRef = useRef(null); // Create a ref to hold the timer ID
  const [count, setCount] = useState(0);

  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setCount((prev) => prev + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    clearInterval(timerRef.current); // Clear the timer
    timerRef.current = null; // Reset the ref
  };

  return (
    <div>
      <h1>Timer with useRef</h1>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<Timer />);
```

#### Explanation:
- `timerRef` is used to store the `setInterval` ID, ensuring it persists across renders.
- The `startTimer` function checks if `timerRef.current` is already set, avoiding multiple intervals.
- The `stopTimer` function clears the interval and resets the reference.

---

### **Key Takeaways**

#### **1. Referencing a Value with a Ref**
- Use `useRef` to store values that should persist across renders but **don’t trigger re-renders**.
- Example: Tracking a count or a previous value.

#### **2. Manipulating the DOM with a Ref**
- Use `useRef` to directly interact with DOM elements.
- Example: Focusing an input, scrolling to an element, or selecting text.

#### **3. Avoiding Recreating the Ref Contents**
- Define `useRef` outside of the render logic to avoid reinitialization.
- Example: Storing `setInterval` IDs, previous props, or other mutable values.

---

### **When to Use `useRef`?**
1. **For Direct DOM Manipulation**: When you need to interact with or modify DOM elements directly.
2. **To Persist Values Without Re-rendering**: When you need to store mutable values that shouldn’t cause re-renders.
3. **For Performance Optimization**: To avoid recreating objects or values on every render.

useTransition Hook 

Here’s a detailed explanation and examples for using the `useTransition` hook in React, covering the following use cases:

1. **Perform Non-blocking Updates with Actions**  
2. **Exposing Action Prop from Components**  
3. **Displaying a Pending Visual State**  
4. **Preventing Unwanted Loading Indicators**  
5. **Building a Suspense-Enabled Router**  
6. **Displaying an Error to Users with an Error Boundary**

---

### **What is `useTransition`?**
The `useTransition` hook enables you to mark updates as **non-blocking**, which means React can prioritize urgent updates (e.g., user input) while deferring less urgent updates (e.g., rendering large components or performing complex calculations). This improves the user experience by keeping the UI responsive.

---

### **Syntax**
```jsx
const [isPending, startTransition] = useTransition();
```

- **`isPending`**: A boolean that indicates whether the transition is in progress.
- **`startTransition`**: A function that you wrap around the non-blocking updates.

---

### **Complete Code Examples**

---

#### **1. Perform Non-blocking Updates with Actions**

##### **Code Example:**
```jsx
import React, { useState, useTransition } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [input, setInput] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value);

    // Perform non-blocking updates for the filtered list
    startTransition(() => {
      const filteredList = Array(10000)
        .fill(0)
        .map((_, i) => `Item ${i}`)
        .filter((item) => item.includes(value));
      setList(filteredList);
    });
  };

  return (
    <div>
      <h1>useTransition Example</h1>
      <input
        type="text"
        value={input}
        onChange={handleChange}
        placeholder="Type to filter..."
      />
      {isPending && <p>Loading...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

##### **Explanation**:
- The `startTransition` function wraps the update to `list`, marking it as non-blocking.
- While the transition is in progress, `isPending` is `true`, and a loading indicator (`Loading...`) is displayed.
- React prioritizes the input update (`setInput`) over the list update (`setList`), keeping the UI responsive.

---

#### **2. Exposing Action Prop from Components**

##### **Code Example:**
```jsx
import React, { useState, useTransition } from "react";

function SearchBar({ onSearch }) {
  const [input, setInput] = useState("");

  const handleInputChange = (e) => {
    setInput(e.target.value);
    onSearch(e.target.value);
  };

  return (
    <input
      type="text"
      value={input}
      onChange={handleInputChange}
      placeholder="Search..."
    />
  );
}

function App() {
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleSearch = (query) => {
    startTransition(() => {
      const filteredList = Array(10000)
        .fill(0)
        .map((_, i) => `Item ${i}`)
        .filter((item) => item.includes(query));
      setList(filteredList);
    });
  };

  return (
    <div>
      <h1>Exposing Action Prop</h1>
      <SearchBar onSearch={handleSearch} />
      {isPending && <p>Loading...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The `SearchBar` component exposes an `onSearch` prop to allow the parent component (`App`) to handle the search logic.
- The `startTransition` function ensures that the filtering logic does not block the UI.

---

#### **3. Displaying a Pending Visual State**

##### **Code Example:**
```jsx
import React, { useState, useTransition } from "react";

function App() {
  const [count, setCount] = useState(0);
  const [isPending, startTransition] = useTransition();

  const increment = () => {
    startTransition(() => {
      setCount((prev) => prev + 1);
    });
  };

  return (
    <div>
      <h1>Pending Visual State</h1>
      <button onClick={increment}>Increment</button>
      {isPending && <p>Updating count...</p>}
      <p>Count: {count}</p>
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The `isPending` state is used to display a "Updating count..." message while the transition is in progress.

---

#### **4. Preventing Unwanted Loading Indicators**

##### **Code Example:**
```jsx
import React, { useState, useTransition } from "react";

function App() {
  const [input, setInput] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setInput(value);

    startTransition(() => {
      if (value) {
        const filteredList = Array(10000)
          .fill(0)
          .map((_, i) => `Item ${i}`)
          .filter((item) => item.includes(value));
        setList(filteredList);
      } else {
        setList([]);
      }
    });
  };

  return (
    <div>
      <h1>Preventing Unwanted Loading Indicators</h1>
      <input
        type="text"
        value={input}
        onChange={handleChange}
        placeholder="Type to filter..."
      />
      {isPending && input && <p>Loading...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The loading indicator (`Loading...`) is only displayed if the input is **not empty**, preventing unnecessary indicators when the input is cleared.

---

#### **5. Building a Suspense-Enabled Router**

##### **Code Example:**
```jsx
import React, { Suspense, useState, useTransition } from "react";

const Page1 = React.lazy(() => import("./Page1"));
const Page2 = React.lazy(() => import("./Page2"));

function App() {
  const [currentPage, setCurrentPage] = useState("Page1");
  const [isPending, startTransition] = useTransition();

  const navigate = (page) => {
    startTransition(() => {
      setCurrentPage(page);
    });
  };

  return (
    <div>
      <h1>Suspense-Enabled Router</h1>
      <button onClick={() => navigate("Page1")}>Page 1</button>
      <button onClick={() => navigate("Page2")}>Page 2</button>
      {isPending && <p>Loading page...</p>}
      <Suspense fallback={<p>Loading...</p>}>
        {currentPage === "Page1" && <Page1 />}
        {currentPage === "Page2" && <Page2 />}
      </Suspense>
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The `startTransition` function ensures that the page navigation is non-blocking.
- The `Suspense` component provides a fallback UI while the page is being lazily loaded.

---

#### **6. Displaying an Error to Users with an Error Boundary**

##### **Code Example:**
```jsx
import React, { Suspense, useState, useTransition } from "react";

function ErrorBoundary({ children }) {
  return (
    <React.Suspense
      fallback={<p>Loading...</p>}
      unstable_expectedError={true}
    >
      {children}
    </React.Suspense>
  );
}

export default ErrorBoundary;
```
useDebugValue Hook

`useDebugValue` is a React Hook that allows you to display custom labels for your custom hooks in React DevTools. This is particularly useful for debugging complex hooks or providing insights into their internal state.

Below are examples and explanations for using `useDebugValue` to cover the scenarios you mentioned:

---

### **1. Perform Non-blocking Updates with Actions**

#### Code Example:
```jsx
import React, { useState, useTransition, useDebugValue } from "react";

function useFilteredList(input) {
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  useDebugValue(list.length > 0 ? "Filtered List Active" : "No Filter Applied");

  const updateList = (query) => {
    startTransition(() => {
      const filteredList = Array(10000)
        .fill(0)
        .map((_, i) => `Item ${i}`)
        .filter((item) => item.includes(query));
      setList(filteredList);
    });
  };

  return { list, isPending, updateList };
}

function App() {
  const [input, setInput] = useState("");
  const { list, isPending, updateList } = useFilteredList(input);

  const handleChange = (e) => {
    setInput(e.target.value);
    updateList(e.target.value);
  };

  return (
    <div>
      <h1>Non-blocking Updates with Actions</h1>
      <input
        type="text"
        value={input}
        onChange={handleChange}
        placeholder="Type to filter..."
      />
      {isPending && <p>Loading...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

---

### **2. Exposing Action Prop from Components**

#### Code Example:
```jsx
import React, { useState, useTransition, useDebugValue } from "react";

function useSearch() {
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  useDebugValue(results.length > 0 ? "Search Active" : "No Search Results");

  const search = (query) => {
    startTransition(() => {
      const filteredResults = Array(10000)
        .fill(0)
        .map((_, i) => `Result ${i}`)
        .filter((result) => result.includes(query));
      setResults(filteredResults);
    });
  };

  return { results, isPending, search };
}

function SearchBar({ onSearch }) {
  const [input, setInput] = useState("");

  const handleInputChange = (e) => {
    setInput(e.target.value);
    onSearch(e.target.value);
  };

  return (
    <input
      type="text"
      value={input}
      onChange={handleInputChange}
      placeholder="Search..."
    />
  );
}

function App() {
  const { results, isPending, search } = useSearch();

  return (
    <div>
      <h1>Exposing Action Prop from Components</h1>
      <SearchBar onSearch={search} />
      {isPending && <p>Searching...</p>}
      <ul>
        {results.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

---

### **3. Displaying a Pending Visual State**

#### Code Example:
```jsx
import React, { useState, useTransition, useDebugValue } from "react";

function useCounter() {
  const [count, setCount] = useState(0);
  const [isPending, startTransition] = useTransition();

  useDebugValue(`Count is ${count}`);

  const increment = () => {
    startTransition(() => {
      setCount((prev) => prev + 1);
    });
  };

  return { count, isPending, increment };
}

function App() {
  const { count, isPending, increment } = useCounter();

  return (
    <div>
      <h1>Displaying a Pending Visual State</h1>
      <button onClick={increment}>Increment</button>
      {isPending && <p>Updating count...</p>}
      <p>Count: {count}</p>
    </div>
  );
}

export default App;
```

---

### **4. Preventing Unwanted Loading Indicators**

#### Code Example:
```jsx
import React, { useState, useTransition, useDebugValue } from "react";

function useFilteredList() {
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  useDebugValue(
    list.length > 0 ? `List length: ${list.length}` : "No items in the list"
  );

  const updateList = (query) => {
    startTransition(() => {
      if (query) {
        const filteredList = Array(10000)
          .fill(0)
          .map((_, i) => `Item ${i}`)
          .filter((item) => item.includes(query));
        setList(filteredList);
      } else {
        setList([]);
      }
    });
  };

  return { list, isPending, updateList };
}

function App() {
  const [input, setInput] = useState("");
  const { list, isPending, updateList } = useFilteredList();

  const handleChange = (e) => {
    setInput(e.target.value);
    updateList(e.target.value);
  };

  return (
    <div>
      <h1>Preventing Unwanted Loading Indicators</h1>
      <input
        type="text"
        value={input}
        onChange={handleChange}
        placeholder="Type to filter..."
      />
      {isPending && input && <p>Loading...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

---

### **5. Building a Suspense-Enabled Router**

#### Code Example:
```jsx
import React, { Suspense, useState, useTransition, useDebugValue } from "react";

const Page1 = React.lazy(() => import("./Page1"));
const Page2 = React.lazy(() => import("./Page2"));

function useNavigation() {
  const [currentPage, setCurrentPage] = useState("Page1");
  const [isPending, startTransition] = useTransition();

  useDebugValue(`Current Page: ${currentPage}`);

  const navigate = (page) => {
    startTransition(() => {
      setCurrentPage(page);
    });
  };

  return { currentPage, isPending, navigate };
}

function App() {
  const { currentPage, isPending, navigate } = useNavigation();

  return (
    <div>
      <h1>Suspense-Enabled Router</h1>
      <button onClick={() => navigate("Page1")}>Page 1</button>
      <button onClick={() => navigate("Page2")}>Page 2</button>
      {isPending && <p>Loading page...</p>}
      <Suspense fallback={<p>Loading...</p>}>
        {currentPage === "Page1" && <Page1 />}
        {currentPage === "Page2" && <Page2 />}
      </Suspense>
    </div>
  );
}

export default App;
```

---

### **6. Displaying an Error to Users with an Error Boundary**

#### Code Example:
```jsx
import React, { Suspense, useDebugValue } from "react";

function ErrorBoundary({ children }) {
  useDebugValue("Error Boundary Active");

  return (
    <React.Suspense fallback={<p>Loading...</p>}>
      {children}
    </React.Suspense>
  );
}

export default ErrorBoundary;
```

---

### **Key Points About `useDebugValue`**
1. **Purpose**:
   - Helps developers debug custom hooks in React DevTools.
   - Adds custom labels or descriptions for hooks.

2. **Usage**:
   - Use it inside custom hooks to display meaningful debug information.

3. **Best Practices**:
   - Use `useDebugValue` sparingly, as it is primarily for development purposes.
   - Avoid adding unnecessary logic to `useDebugValue`.

useDeferredValue Hook 

Here’s a detailed explanation and examples for using the `useDeferredValue` hook in React, covering the following use cases:

---

### **What is `useDeferredValue`?**
The `useDeferredValue` hook allows you to defer updates to a value, making your UI more responsive by showing stale content while fresh content is being calculated or fetched. This is particularly useful for scenarios where rendering large or complex components might block the browser.

---

### **Syntax**
```jsx
const deferredValue = useDeferredValue(value);
```

- **`value`**: The value whose updates you want to defer.
- **`deferredValue`**: The deferred version of the value, which may lag behind the actual value if React is busy rendering.

---

### **Use Cases**

---

#### **1. Showing Stale Content While Fresh Content is Loading**

##### **Code Example:**
```jsx
import React, { useState, useDeferredValue } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [input, setInput] = useState("");
  const deferredInput = useDeferredValue(input);

  const list = Array(10000)
    .fill(0)
    .map((_, i) => `Item ${i}`)
    .filter((item) => item.includes(deferredInput));

  return (
    <div>
      <h1>Showing Stale Content</h1>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Type to filter..."
      />
      <p>Input: {input}</p>
      <p>Deferred Input: {deferredInput}</p>
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

##### **Explanation**:
- **`input`**: The immediate value that updates as the user types.
- **`deferredInput`**: The deferred value that updates after React finishes rendering.
- The UI shows the `input` immediately while the `list` is filtered based on the `deferredInput`, preventing the UI from freezing during heavy calculations.

---

#### **2. Indicating That the Content is Stale**

##### **Code Example:**
```jsx
import React, { useState, useDeferredValue } from "react";

function App() {
  const [input, setInput] = useState("");
  const deferredInput = useDeferredValue(input);

  const isStale = deferredInput !== input;

  const list = Array(10000)
    .fill(0)
    .map((_, i) => `Item ${i}`)
    .filter((item) => item.includes(deferredInput));

  return (
    <div>
      <h1>Indicating Stale Content</h1>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Type to filter..."
      />
      {isStale && <p>Updating content...</p>}
      <ul>
        {list.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The `isStale` variable checks if the `deferredInput` is lagging behind the `input`.
- A message (`Updating content...`) is displayed to indicate that the content is stale while React processes the deferred updates.

---

#### **3. Deferring Re-rendering for a Part of the UI**

##### **Code Example:**
```jsx
import React, { useState, useDeferredValue } from "react";

function SlowComponent({ deferredInput }) {
  const list = Array(10000)
    .fill(0)
    .map((_, i) => `Item ${i}`)
    .filter((item) => item.includes(deferredInput));

  return (
    <ul>
      {list.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

function App() {
  const [input, setInput] = useState("");
  const deferredInput = useDeferredValue(input);

  return (
    <div>
      <h1>Deferring Re-rendering for a Part of the UI</h1>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Type to filter..."
      />
      <p>Input: {input}</p>
      {/* SlowComponent uses deferredInput to avoid blocking the UI */}
      <SlowComponent deferredInput={deferredInput} />
    </div>
  );
}

export default App;
```

##### **Explanation**:
- The `SlowComponent` renders the filtered list based on the `deferredInput`.
- Deferring the updates to `SlowComponent` ensures that the input field remains responsive even when the list is large.

---

### **Key Points**

#### **1. Showing Stale Content**
- `useDeferredValue` allows you to show the previous value while React processes the new value.
- This prevents the UI from freezing during heavy computations.

#### **2. Indicating Stale Content**
- Compare the immediate value (`input`) with the deferred value (`deferredInput`) to indicate when the content is stale.

#### **3. Deferring Re-rendering**
- Use `useDeferredValue` to defer updates for parts of the UI that involve expensive rendering or calculations, keeping the rest of the UI responsive.

---

### **When to Use `useDeferredValue`**
1. **Heavy Computations**: When filtering, sorting, or rendering large datasets.
2. **Responsive UI**: To ensure user input remains responsive while React processes deferred updates.
3. **Optimized Rendering**: To defer updates for non-critical parts of the UI.

What is useImperativeHandle?
The useImperativeHandle hook allows you to customize the value exposed via a ref from a child component to its parent. This is useful for exposing imperative methods and controlling child components programmatically.
Syntax
jsx

Copy
useImperativeHandle(ref, createHandle, [dependencies]);
ref: A ref object passed from the parent component via React.forwardRef.
createHandle: A function that returns an object containing the methods or values you want to expose.
dependencies: An array of dependencies that determine when the handle should be updated.
Use Cases
1. Exposing a Custom Ref Handle to the Parent Component
Code Example:
jsx

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";
import ReactDOM from "react-dom/client";

const Input = forwardRef((props, ref) => {
  const inputRef = useRef();

  // Expose custom methods to the parent component
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = "";
    },
  }));

  return <input ref={inputRef} type="text" placeholder="Enter text..." />;
});

function App() {
  const inputRef = useRef();

  const handleFocus = () => {
    inputRef.current.focus(); // Call the exposed `focus` method
  };

  const handleClear = () => {
    inputRef.current.clear(); // Call the exposed `clear` method
  };

  return (
    <div>
      <h1>Exposing a Custom Ref Handle</h1>
      <Input ref={inputRef} />
      <button onClick={handleFocus}>Focus Input</button>
      <button onClick={handleClear}>Clear Input</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
Explanation:
Child Component (Input):
The useImperativeHandle hook is used to define custom methods (focus and clear) that are exposed to the parent.
The inputRef is used internally to perform DOM manipulation.
Parent Component (App):
The ref passed to the Input component allows the parent to call the exposed methods (focus and clear) programmatically.
2. Exposing Your Own Imperative Methods
Code Example:
jsx

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";

const Counter = forwardRef((props, ref) => {
  let count = 0;

  // Expose custom methods to the parent component
  useImperativeHandle(ref, () => ({
    increment: () => {
      count += 1;
      console.log("Count:", count);
    },
    reset: () => {
      count = 0;
      console.log("Count reset to:", count);
    },
  }));

  return <p>Open the console to see the count updates.</p>;
});

function App() {
  const counterRef = useRef();

  const handleIncrement = () => {
    counterRef.current.increment(); // Call the exposed `increment` method
  };

  const handleReset = () => {
    counterRef.current.reset(); // Call the exposed `reset` method
  };

  return (
    <div>
      <h1>Exposing Your Own Imperative Methods</h1>
      <Counter ref={counterRef} />
      <button onClick={handleIncrement}>Increment Count</button>
      <button onClick={handleReset}>Reset Count</button>
    </div>
  );
}

export default App;

Explanation:

Child Component (Counter):
The useImperativeHandle hook is used to expose custom methods (increment and reset) to the parent.
The count variable is managed internally within the child component.
Parent Component (App):
The parent component uses the ref to call the custom methods (increment and reset) exposed by the child.
Key Points

1. Exposing a Custom Ref Handle
Use useImperativeHandle to define custom methods or values that the parent component can access via a ref.
Combine useImperativeHandle with React.forwardRef to pass the ref from the parent to the child.
2. Exposing Imperative Methods
You can expose methods like focus, clear, increment, or reset to control child components programmatically.
This is useful for cases where you need fine-grained control over child components.
3. Best Practices
Avoid Overuse: Use useImperativeHandle sparingly. Prefer declarative solutions (e.g., props) whenever possible.

Dependencies: Specify dependencies in the hook to ensure the handle is updated when necessary.

Forwarding Ref: Always wrap the child component with React.forwardRef when using useImperativeHandle.

When to Use useImperativeHandle

Custom Methods: When you need to expose custom methods to the parent component.

DOM Manipulation: When you need to perform direct DOM operations like focusing or clearing inputs.

Imperative Control: When declarative solutions are insufficient for controlling child components.

useActionState Hook 

Here’s a detailed explanation and examples for using the `useActionState` hook in React, covering the following use cases:

---

### **What is `useActionState`?**
The `useActionState` hook allows you to manage state that is updated based on the result of a form action. It simplifies handling state updates when a form is submitted, particularly in scenarios where you need to display information returned by the action or handle pending states.

---

### **Syntax**
```jsx
const [state, formAction, isPending] = useActionState(action, initialState, permalink?);
```

- **`state`**: The current state of the form, initially set to `initialState`. After form submission, it is updated with the return value of the action.
- **`formAction`**: A function that can be used as the `action` attribute for a `<form>` or the `formAction` prop for a `<button>`.
- **`isPending`**: A boolean indicating whether the action is still in progress.

---

### **Use Cases**

---

#### **1. Using Information Returned by a Form Action**

##### **Code Example:**
```jsx
import React from "react";
import { useActionState } from "react";

// Action function to increment a counter
async function incrementCounter(previousState, formData) {
  return previousState + 1; // Increment the previous state
}

function CounterForm() {
  const [count, formAction, isPending] = useActionState(incrementCounter, 0);

  return (
    <form>
      <h1>Count: {count}</h1>
      <button formAction={formAction} disabled={isPending}>
        {isPending ? "Incrementing..." : "Increment"}
      </button>
    </form>
  );
}

export default CounterForm;
```

##### **Explanation**:
- **`incrementCounter`**: The action function receives the current state (`previousState`) and form data (`formData`). It increments the counter and returns the new state.
- **`useActionState`**: Manages the `count` state, updates it after the form is submitted, and provides the `isPending` flag to handle loading states.

---

#### **2. Displaying Form Errors**

##### **Code Example:**
```jsx
import React from "react";
import { useActionState } from "react";

// Action function to simulate adding an item to a cart
async function addToCart(currentState, formData) {
  const itemID = formData.get("itemID");
  if (!itemID) {
    return "Error: Item ID is required.";
  }
  return `Item ${itemID} added to cart successfully!`;
}

function AddToCartForm({ itemID, itemTitle }) {
  const [message, formAction, isPending] = useActionState(addToCart, null);

  return (
    <form action={formAction}>
      <h2>{itemTitle}</h2>
      <input type="hidden" name="itemID" value={itemID} />
      <button type="submit" disabled={isPending}>
        {isPending ? "Adding..." : "Add to Cart"}
      </button>
      {message && <p>{message}</p>}
    </form>
  );
}

function App() {
  return (
    <div>
      <AddToCartForm itemID="1" itemTitle="JavaScript: The Definitive Guide" />
      <AddToCartForm itemID="2" itemTitle="JavaScript: The Good Parts" />
    </div>
  );
}

export default App;
```

##### **Explanation**:
- **`addToCart`**: The action function validates the form data and returns either an error message or a success message.
- **`useActionState`**: Tracks the message returned by the action and the pending state (`isPending`) to disable the button while the action is in progress.

---

#### **3. Displaying Structured Information After Submitting a Form**

##### **Code Example:**
```jsx
import React from "react";
import { useActionState } from "react";

// Action function to simulate submitting a form
async function submitForm(currentState, formData) {
  const name = formData.get("name");
  const email = formData.get("email");
  if (!name || !email) {
    return { error: "Name and Email are required." };
  }
  return { name, email, success: "Form submitted successfully!" };
}

function ContactForm() {
  const [state, formAction, isPending] = useActionState(submitForm, {});

  return (
    <form action={formAction}>
      <h1>Contact Form</h1>
      <input type="text" name="name" placeholder="Name" />
      <input type="email" name="email" placeholder="Email" />
      <button type="submit" disabled={isPending}>
        {isPending ? "Submitting..." : "Submit"}
      </button>
      {state.error && <p style={{ color: "red" }}>{state.error}</p>}
      {state.success && <p style={{ color: "green" }}>{state.success}</p>}
      {state.name && <p>Name: {state.name}</p>}
      {state.email && <p>Email: {state.email}</p>}
    </form>
  );
}

export default ContactForm;
```

##### **Explanation**:
- **`submitForm`**: The action function validates the form data and returns structured information, including success or error messages.
- **`useActionState`**: Tracks the structured state (`state`) and updates it after form submission.

---

### **Parameters**

1. **`action`**: The function to execute when the form is submitted. It receives:
   - The current state (`previousState`) as the first argument.
   - The form data (`formData`) as the second argument.

2. **`initialState`**: The initial value for the state, which can be any serializable value.

3. **`permalink` (optional)**: A string containing the unique page URL for the form. Useful for server-side rendering and progressive enhancement.

---

### **Returns**

1. **`state`**: The current state of the form, which updates after the action is executed.
2. **`formAction`**: A function to use as the `action` attribute for the form or the `formAction` prop for buttons.
3. **`isPending`**: A boolean indicating whether the action is still in progress.

---

### **Key Points**

#### **1. Using Information Returned by a Form Action**
- The `useActionState` hook updates the state with the return value of the action function after the form is submitted.

#### **2. Displaying Form Errors**
- You can display error messages returned by the action function directly in the UI.

#### **3. Structured Information**
- The action function can return structured data (e.g., objects) to update the state with more detailed information.

#### **4. Pending State**
- The `isPending` flag helps manage loading indicators and prevents duplicate submissions.

#### **5. Server-Side Integration**
- The `permalink` parameter ensures the form works seamlessly with server-side rendering and progressive enhancement.

---

useImperativeHandle  Hook 

What is useImperativeHandle?
The useImperativeHandle hook allows you to customize the value exposed via a ref from a child component to its parent. This is useful for exposing imperative methods and controlling child components programmatically.
Syntax
jsx

Copy
useImperativeHandle(ref, createHandle, [dependencies]);
ref: A ref object passed from the parent component via React.forwardRef.
createHandle: A function that returns an object containing the methods or values you want to expose.
dependencies: An array of dependencies that determine when the handle should be updated.
Use Cases
1. Exposing a Custom Ref Handle to the Parent Component
Code Example:
jsx

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";
import ReactDOM from "react-dom/client";

const Input = forwardRef((props, ref) => {
  const inputRef = useRef();

  // Expose custom methods to the parent component
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = "";
    },
  }));

  return <input ref={inputRef} type="text" placeholder="Enter text..." />;
});

function App() {
  const inputRef = useRef();

  const handleFocus = () => {
    inputRef.current.focus(); // Call the exposed `focus` method
  };

  const handleClear = () => {
    inputRef.current.clear(); // Call the exposed `clear` method
  };

  return (
    <div>
      <h1>Exposing a Custom Ref Handle</h1>
      <Input ref={inputRef} />
      <button onClick={handleFocus}>Focus Input</button>
      <button onClick={handleClear}>Clear Input</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
Explanation:
Child Component (Input):
The useImperativeHandle hook is used to define custom methods (focus and clear) that are exposed to the parent.
The inputRef is used internally to perform DOM manipulation.
Parent Component (App):
The ref passed to the Input component allows the parent to call the exposed methods (focus and clear) programmatically.
2. Exposing Your Own Imperative Methods
Code Example:
jsx

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";

const Counter = forwardRef((props, ref) => {
  let count = 0;

  // Expose custom methods to the parent component
  useImperativeHandle(ref, () => ({
    increment: () => {
      count += 1;
      console.log("Count:", count);
    },
    reset: () => {
      count = 0;
      console.log("Count reset to:", count);
    },
  }));

  return <p>Open the console to see the count updates.</p>;
});

function App() {
  const counterRef = useRef();

  const handleIncrement = () => {
    counterRef.current.increment(); // Call the exposed `increment` method
  };

  const handleReset = () => {
    counterRef.current.reset(); // Call the exposed `reset` method
  };

  return (
    <div>
      <h1>Exposing Your Own Imperative Methods</h1>
      <Counter ref={counterRef} />
      <button onClick={handleIncrement}>Increment Count</button>
      <button onClick={handleReset}>Reset Count</button>
    </div>
  );
}

export default App;
Explanation:
Child Component (Counter):
The useImperativeHandle hook is used to expose custom methods (increment and reset) to the parent.
The count variable is managed internally within the child component.
Parent Component (App):
The parent component uses the ref to call the custom methods (increment and reset) exposed by the child.
Key Points
1. Exposing a Custom Ref Handle
Use useImperativeHandle to define custom methods or values that the parent component can access via a ref.
Combine useImperativeHandle with React.forwardRef to pass the ref from the parent to the child.
2. Exposing Imperative Methods
You can expose methods like focus, clear, increment, or reset to control child components programmatically.
This is useful for cases where you need fine-grained control over child components.
3. Best Practices
Avoid Overuse: Use useImperativeHandle sparingly. Prefer declarative solutions (e.g., props) whenever possible.
Dependencies: Specify dependencies in the hook to ensure the handle is updated when necessary.
Forwarding Ref: Always wrap the child component with React.forwardRef when using useImperativeHandle.

1. useInsertionEffect
Description:
The useInsertionEffect hook is designed for injecting styles or performing DOM mutations before the browser paints. It runs synchronously after all React updates but before the browser renders the screen. This makes it particularly useful for CSS-in-JS libraries like emotion or styled-components where styles need to be applied before rendering.
Code Example:
jsx

```jsx
import React, { useInsertionEffect, useState } from "react";
import ReactDOM from "react-dom/client";

function StyledComponent() {
  const [color, setColor] = useState("blue");

  useInsertionEffect(() => {
    const style = document.createElement("style");
    style.textContent = `
      .dynamic-style {
        background-color: ${color};
        color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: center;
      }
    `;
    document.head.appendChild(style);

    // Cleanup to remove the style element
    return () => {
      document.head.removeChild(style);
    };
  }, [color]);

  return (
    <div>
      <div className="dynamic-style">Dynamic Styled Component</div>
      <button onClick={() => setColor("red")}>Change to Red</button>
      <button onClick={() => setColor("green")}>Change to Green</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<StyledComponent />);
Explanation:
The useInsertionEffect hook injects a <style> tag into the document head before rendering the component.
The color state determines the background color, and updating it dynamically changes the styles.
Cleanup ensures the <style> tag is removed when the component unmounts.
2. useOptimistic
Description:
The useOptimistic hook is used to manage optimistic updates, where the UI is updated immediately to reflect the expected result before the actual operation (e.g., API call) is completed. It helps in improving the user experience by reducing the perceived latency.
Code Example:
jsx

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom/client";

function useOptimistic(initialState) {
  const [state, setState] = useState(initialState);

  const updateOptimistically = (updateFn) => {
    const previousState = state;
    const optimisticState = updateFn(previousState);
    setState(optimisticState);

    return {
      rollback: () => setState(previousState),
    };
  };

  return [state, updateOptimistically];
}

function OptimisticCounter() {
  const [count, updateOptimistically] = useOptimistic(0);

  const handleIncrement = () => {
    const { rollback } = updateOptimistically((prev) => prev + 1);

    // Simulate an API call
    setTimeout(() => {
      const success = Math.random() > 0.5; // Random success/failure
      if (!success) {
        rollback(); // Rollback if the operation fails
        alert("Failed to update count!");
      }
    }, 1000);
  };

  return (
    <div>
      <h1>Optimistic Counter</h1>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<OptimisticCounter />);
Explanation:
The useOptimistic hook manages optimistic updates by providing an updateOptimistically function.
The rollback method allows reverting to the previous state if the operation fails.
The UI updates immediately when the button is clicked, but it rolls back if the simulated API call fails.
3. useSyncExternalStore
Description:
The useSyncExternalStore hook is used to subscribe to external data sources (e.g., global state, Redux store, or browser APIs) and keeps the component synchronized with the external store. It is particularly useful for managing state outside React.
Code Example:
jsx

```jsx
import React, { useSyncExternalStore } from "react";
import ReactDOM from "react-dom/client";

// Simulated external store
const store = {
  currentValue: 0,
  listeners: new Set(),

  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  },

  setValue(value) {
    this.currentValue = value;
    this.listeners.forEach((listener) => listener());
  },

  getSnapshot() {
    return this.currentValue;
  },
};

function Counter() {
  const value = useSyncExternalStore(
    store.subscribe,
    store.getSnapshot,
    store.getSnapshot // Fallback for server rendering
  );

  const handleIncrement = () => {
    store.setValue(value + 1);
  };

  return (
    <div>
      <h1>Sync External Store</h1>
      <p>Value: {value}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<Counter />);

Explanation:
The useSyncExternalStore hook subscribes to the external store (store) and keeps the component synchronized with its state.
The subscribe method registers a listener to notify the component when the store updates.
The getSnapshot method retrieves the current value of the store, ensuring the component always reflects the latest state.
Key Points
1. useInsertionEffect Hook
Runs before rendering and is ideal for injecting styles or performing DOM mutations.
Useful for CSS-in-JS libraries or scenarios requiring synchronous style updates.
2. useOptimistic
Handles optimistic updates by immediately updating the UI and rolling back if the operation fails.
Improves user experience by reducing perceived latency.
3. useSyncExternalStore Hook 
Subscribes to external data sources and ensures the component stays in sync with the external store.
Ideal for integrating global state management solutions like Redux or browser APIs.


